{"version":3,"file":"index.js","sources":["../src/expect/core.ts","../src/expect/matchers/js.ts","../src/expect/matchers/aftereffects.ts","../src/describe.ts","../src/expect/index.ts","../src/runner.ts","../node_modules/kt-core/src/KtCore.ts","../src/tests/index.test.ts"],"sourcesContent":["// lib/expect/core.ts\r\nexport class Expect<T> {\r\n    protected actual: T;\r\n\r\n    constructor(actual: T) {\r\n        this.actual = actual;\r\n    }\r\n\r\n    protected assert(condition: boolean, message: string): void {\r\n        if (!condition) {\r\n            throw new Error(message);\r\n        }\r\n    }\r\n\r\n    protected toSafeString(value: any): string {\r\n        if (value === null) {\r\n            return 'null';\r\n        }\r\n        if (value === undefined) {\r\n            return 'undefined';\r\n        }\r\n        return value.toString();\r\n    }\r\n\r\n    // Método para obtener una versión segura de this.actual según el tipo esperado\r\n    protected getSafeActual(type: 'array' | 'string' | 'number' | 'any'): any {\r\n        if (this.actual === null || this.actual === undefined) {\r\n            if (type === 'array') {\r\n                return [];\r\n            }\r\n            if (type === 'string') {\r\n                return '';\r\n            }\r\n            if (type === 'number') {\r\n                return NaN;\r\n            }\r\n            return this.actual; // null o undefined para \"any\"\r\n        }\r\n        if (type === 'array') {\r\n            if (this.actual && (this.actual as any).constructor === Array) {\r\n                return this.actual;\r\n            }\r\n            return [];\r\n        }\r\n        if (type === 'string') {\r\n            if (typeof this.actual === 'string') {\r\n                return this.actual;\r\n            }\r\n            return '';\r\n        }\r\n        if (type === 'number') {\r\n            if (\r\n                typeof this.actual === 'number' &&\r\n                !isNaN(this.actual as number)\r\n            ) {\r\n                return this.actual;\r\n            }\r\n            return NaN;\r\n        }\r\n        return this.actual; // Siempre retorna algo\r\n    }\r\n}\r\n\r\nexport interface Matcher<T> {\r\n    [key: string]: (expected?: any, ...args: any[]) => void;\r\n}\r\n\r\nexport function createExpect<T>(\r\n    actual: T,\r\n    matchers: Matcher<T>[] = []\r\n): Expect<T> & Matcher<T> {\r\n    const expectInstance = new Expect(actual) as Expect<T> & Matcher<T>;\r\n\r\n    for (var i = 0; i < matchers.length; i++) {\r\n        var matcherGroup = matchers[i];\r\n        for (var key in matcherGroup) {\r\n            if (matcherGroup.hasOwnProperty(key)) {\r\n                expectInstance[key] = matcherGroup[key];\r\n            }\r\n        }\r\n    }\r\n\r\n    return expectInstance;\r\n}\r\n","// lib/expect/matchers/js.ts\r\nimport { Matcher } from '../core';\r\n\r\nexport const jsMatchers: Matcher<any> = {\r\n    toThrow: function () {\r\n        var isFunction = false;\r\n        if (typeof this.actual === 'function') {\r\n            isFunction = true;\r\n        }\r\n        var threw = false;\r\n        if (isFunction) {\r\n            try {\r\n                (this.actual as () => void)(); // Ejecutar la función, forzando tipo para evitar TS errors\r\n            } catch (e) {\r\n                threw = true;\r\n            }\r\n        }\r\n        this.assert(\r\n            threw,\r\n            'Expected ' +\r\n                this.toSafeString(this.actual) +\r\n                ' to throw an error, but it did not'\r\n        );\r\n        return this;\r\n    },\r\n    toBe: function (expected: any) {\r\n        var safeActual: any = this.getSafeActual('any');\r\n        this.assert(\r\n            safeActual === expected,\r\n            'Expected ' +\r\n                expected +\r\n                ' but got ' +\r\n                this.toSafeString(this.actual)\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toEqual: function (expected: object) {\r\n        var safeActual: any = this.getSafeActual('any');\r\n        var actualStr = JSON.stringify(safeActual);\r\n        var expectedStr = JSON.stringify(expected);\r\n        this.assert(\r\n            actualStr === expectedStr,\r\n            'Expected ' + expectedStr + ' but got ' + actualStr\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeDefined: function () {\r\n        this.assert(\r\n            this.actual !== undefined,\r\n            'Expected value to be defined, but got undefined'\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeUndefined: function () {\r\n        this.assert(\r\n            this.actual === undefined,\r\n            'Expected value to be undefined, but got ' +\r\n                this.toSafeString(this.actual)\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeNull: function () {\r\n        this.assert(\r\n            this.actual === null,\r\n            'Expected value to be null, but got ' +\r\n                this.toSafeString(this.actual)\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeTruthy: function () {\r\n        var safeActual: any = this.getSafeActual('any');\r\n        var isTruthy = !!safeActual;\r\n        this.assert(\r\n            isTruthy,\r\n            'Expected value to be truthy, but got ' +\r\n                this.toSafeString(this.actual)\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeFalsy: function () {\r\n        var safeActual: any = this.getSafeActual('any');\r\n        var isFalsy = !safeActual;\r\n        this.assert(\r\n            isFalsy,\r\n            'Expected value to be falsy, but got ' +\r\n                this.toSafeString(this.actual)\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeArray: function () {\r\n        var isArray = false;\r\n        if (this.actual && (this.actual as any).constructor === Array) {\r\n            isArray = true;\r\n        }\r\n        this.assert(\r\n            isArray,\r\n            'Expected ' + this.toSafeString(this.actual) + ' to be an array'\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeEmpty: function () {\r\n        var isArray = false;\r\n        var isString = false;\r\n        if (this.actual && (this.actual as any).constructor === Array) {\r\n            isArray = true;\r\n        }\r\n        if (typeof this.actual === 'string') {\r\n            isString = true;\r\n        }\r\n        // Consider null/undefined as empty (array or string)\r\n        var isArrayOrString =\r\n            isArray ||\r\n            isString ||\r\n            this.actual === null ||\r\n            this.actual === undefined;\r\n        var safeActual: any = this.getSafeActual(isArray ? 'array' : 'string');\r\n        this.assert(\r\n            isArrayOrString && safeActual.length === 0,\r\n            'Expected ' + this.toSafeString(this.actual) + ' to be empty'\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toHaveLength: function (expected: number) {\r\n        var isArray = false;\r\n        var isString = false;\r\n        if (this.actual && (this.actual as any).constructor === Array) {\r\n            isArray = true;\r\n        }\r\n        if (typeof this.actual === 'string') {\r\n            isString = true;\r\n        }\r\n        // Consider null/undefined as having length 0\r\n        var isArrayOrString =\r\n            isArray ||\r\n            isString ||\r\n            this.actual === null ||\r\n            this.actual === undefined;\r\n        var safeActual: any = this.getSafeActual(isArray ? 'array' : 'string');\r\n        this.assert(\r\n            isArrayOrString && safeActual.length === expected,\r\n            'Expected ' +\r\n                this.toSafeString(this.actual) +\r\n                ' to have length ' +\r\n                expected +\r\n                ' but got ' +\r\n                safeActual.length\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeNumber: function () {\r\n        var safeActual: any = this.getSafeActual('number');\r\n        var isNumber = false;\r\n        if (typeof this.actual === 'number' && !isNaN(safeActual)) {\r\n            isNumber = true;\r\n        }\r\n        this.assert(\r\n            isNumber,\r\n            'Expected ' + this.toSafeString(this.actual) + ' to be a number'\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeNaN: function () {\r\n        var safeActual: any = this.getSafeActual('number');\r\n        this.assert(\r\n            isNaN(safeActual),\r\n            'Expected ' + this.toSafeString(this.actual) + ' to be NaN'\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeString: function () {\r\n        var isString = false;\r\n        if (typeof this.actual === 'string') {\r\n            isString = true;\r\n        }\r\n        this.assert(\r\n            isString,\r\n            'Expected ' + this.toSafeString(this.actual) + ' to be a string'\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeBoolean: function () {\r\n        var isBoolean = false;\r\n        if (typeof this.actual === 'boolean') {\r\n            isBoolean = true;\r\n        }\r\n        this.assert(\r\n            isBoolean,\r\n            'Expected ' + this.toSafeString(this.actual) + ' to be a boolean'\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeFunction: function () {\r\n        var isFunction = false;\r\n        if (typeof this.actual === 'function') {\r\n            isFunction = true;\r\n        }\r\n        this.assert(\r\n            isFunction,\r\n            'Expected ' + this.toSafeString(this.actual) + ' to be a function'\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeGreaterThan: function (expected: number) {\r\n        var safeActual: any = this.getSafeActual('number');\r\n        var isGreater = false;\r\n        if (\r\n            typeof this.actual === 'number' &&\r\n            !isNaN(safeActual) &&\r\n            safeActual > expected\r\n        ) {\r\n            isGreater = true;\r\n        }\r\n        this.assert(\r\n            isGreater,\r\n            'Expected ' +\r\n                this.toSafeString(this.actual) +\r\n                ' to be greater than ' +\r\n                expected\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeLessThan: function (expected: number) {\r\n        var safeActual: any = this.getSafeActual('number');\r\n        var isLess = false;\r\n        if (\r\n            typeof this.actual === 'number' &&\r\n            !isNaN(safeActual) &&\r\n            safeActual < expected\r\n        ) {\r\n            isLess = true;\r\n        }\r\n        this.assert(\r\n            isLess,\r\n            'Expected ' +\r\n                this.toSafeString(this.actual) +\r\n                ' to be less than ' +\r\n                expected\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeGreaterThanOrEqual: function (expected: number) {\r\n        var safeActual: any = this.getSafeActual('number');\r\n        var isGreaterOrEqual = false;\r\n        if (\r\n            typeof this.actual === 'number' &&\r\n            !isNaN(safeActual) &&\r\n            safeActual >= expected\r\n        ) {\r\n            isGreaterOrEqual = true;\r\n        }\r\n        this.assert(\r\n            isGreaterOrEqual,\r\n            'Expected ' +\r\n                this.toSafeString(this.actual) +\r\n                ' to be greater than or equal to ' +\r\n                expected\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeLessThanOrEqual: function (expected: number) {\r\n        var safeActual: any = this.getSafeActual('number');\r\n        var isLessOrEqual = false;\r\n        if (\r\n            typeof this.actual === 'number' &&\r\n            !isNaN(safeActual) &&\r\n            safeActual <= expected\r\n        ) {\r\n            isLessOrEqual = true;\r\n        }\r\n        this.assert(\r\n            isLessOrEqual,\r\n            'Expected ' +\r\n                this.toSafeString(this.actual) +\r\n                ' to be less than or equal to ' +\r\n                expected\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toContain: function (expected: string) {\r\n        var safeActual: any = this.getSafeActual('string');\r\n        var contains = false;\r\n        if (\r\n            typeof this.actual === 'string' &&\r\n            safeActual.indexOf(expected) !== -1\r\n        ) {\r\n            contains = true;\r\n        }\r\n        this.assert(\r\n            contains,\r\n            'Expected ' +\r\n                this.toSafeString(this.actual) +\r\n                ' to contain ' +\r\n                expected\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toInclude: function (expected: any) {\r\n        var isArray = false;\r\n        if (this.actual && (this.actual as any).constructor === Array) {\r\n            isArray = true;\r\n        }\r\n        var safeActual: any = this.getSafeActual('array');\r\n        var includes = false;\r\n        if (isArray) {\r\n            for (var i = 0; i < safeActual.length; i++) {\r\n                if (safeActual[i] === expected) {\r\n                    includes = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        this.assert(\r\n            includes,\r\n            'Expected ' +\r\n                this.toSafeString(this.actual) +\r\n                ' to include ' +\r\n                this.toSafeString(expected)\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeInstanceOf: function (expected: Function) {\r\n        // Handle undefined and null explicitly\r\n        if (this.actual === undefined) {\r\n            this.assert(\r\n                false,\r\n                'Expected value to be an instance of ' +\r\n                    (expected.name || 'unknown type') +\r\n                    ', but got undefined'\r\n            );\r\n        }\r\n        if (this.actual === null) {\r\n            this.assert(\r\n                false,\r\n                'Expected value to be an instance of ' +\r\n                    (expected.name || 'unknown type') +\r\n                    ', but got null'\r\n            );\r\n        }\r\n\r\n        var isInstance = false;\r\n        // Check constructor for native JS types (Number, String, etc.) and Adobe types (CompItem, Layer, etc.)\r\n        if (\r\n            this.actual &&\r\n            this.actual.constructor &&\r\n            this.actual.constructor === expected\r\n        ) {\r\n            isInstance = true;\r\n        }\r\n        // Fallback: Use instanceof for user-defined classes or edge cases\r\n        else if (this.actual && this.actual instanceof expected) {\r\n            isInstance = true;\r\n        }\r\n\r\n        this.assert(\r\n            isInstance,\r\n            'Expected ' +\r\n                this.toSafeString(this.actual) +\r\n                ' to be an instance of ' +\r\n                (expected.name || 'unknown type')\r\n        );\r\n        return this;\r\n    }\r\n};\r\n","// lib/expect/matchers/aftereffects.ts\r\nimport { Matcher } from '../core';\r\n\r\n// Asumimos que CompItem está definido en tus tipos de Adobe\r\nexport const afterEffectsMatchers: Matcher<CompItem> = {\r\n    toBeActiveComp: function () {\r\n        this.assert(\r\n            this.actual instanceof CompItem &&\r\n                app.project.activeItem === this.actual,\r\n            'Expected ' +\r\n                (this.actual instanceof CompItem\r\n                    ? this.actual.name\r\n                    : 'unknown') +\r\n                ' to be the active composition, but it is not'\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toHaveDuration: function (expected: number) {\r\n        var actualDuration =\r\n            this.actual instanceof CompItem\r\n                ? this.actual.duration\r\n                : 'undefined';\r\n        this.assert(\r\n            this.actual instanceof CompItem &&\r\n                this.actual.duration === expected,\r\n            'Expected duration ' + expected + ' but got ' + actualDuration\r\n        );\r\n        return this;\r\n    },\r\n\r\n    toBeComp: function () {\r\n        this.assert(\r\n            this.actual && this.actual.toString() === '[object CompItem]',\r\n            'Expected ' + this.actual.toString() + ' to be a composition'\r\n        );\r\n        return this;\r\n    }\r\n};\r\n","// lib/describe.ts\r\nimport { Test, Suite, TestFn } from './types';\r\n\r\nconst suites: Suite[] = [];\r\nlet currentSuite: Suite | null = null;\r\n\r\nexport function describe(description: string, fn: () => void): void {\r\n    const tests: Test[] = [];\r\n    currentSuite = { description, tests };\r\n    suites.push(currentSuite);\r\n\r\n    // Ejecutar el contenido para recolectar pruebas\r\n    fn();\r\n    currentSuite = null; // Resetear después de recolectar\r\n}\r\n\r\nexport function it(name: string, fn: TestFn): void {\r\n    if (!currentSuite) {\r\n        throw new Error('it() must be called inside a describe()');\r\n    }\r\n    currentSuite.tests.push({ name, fn });\r\n}\r\n\r\nexport function getSuites(): Suite[] {\r\n    return suites;\r\n}\r\n","import { createExpect, Matcher, Expect } from './core';\r\nimport { jsMatchers } from './matchers/js';\r\nimport { afterEffectsMatchers } from './matchers/aftereffects';\r\nimport { describe, it, getSuites } from '../describe';\r\n\r\nexport function expect<T>(actual: T): Expect<T> & Matcher<T> {\r\n    return createExpect(actual, [jsMatchers]);\r\n}\r\n\r\nexport namespace AE {\r\n    export function expect<T>(actual: T): Expect<T> & Matcher<T> {\r\n        return createExpect(actual, [jsMatchers, afterEffectsMatchers]);\r\n    }\r\n}\r\n\r\nexport { describe, it, getSuites };\r\n","// lib/runner.ts\r\nimport { Suite } from './types';\r\nimport { getSuites } from './describe';\r\nexport class TestRunner {\r\n    private passedTests = 0;\r\n    private failedTests = 0;\r\n\r\n    run(suites: Suite[]): void {\r\n        for (const suite of suites) {\r\n            $.writeln(`Suite: ${suite.description}`);\r\n            for (const test of suite.tests) {\r\n                $.writeln(`  Test: ${test.name}`);\r\n                try {\r\n                    test.fn();\r\n                    this.passedTests++;\r\n                    $.writeln('    ✅ Passed');\r\n                } catch (e: any) {\r\n                    this.failedTests++;\r\n                    $.writeln(`    ❌ Failed: ${e.message}\r\n                        ${e.fileName}\r\n                        ${e.line}`);\r\n                }\r\n            }\r\n        }\r\n        this.showResults();\r\n    }\r\n\r\n    private showResults(): void {\r\n        $.writeln('\\nTest Results:');\r\n        $.writeln(`Passed: ${this.passedTests}`);\r\n        $.writeln(`Failed: ${this.failedTests}`);\r\n    }\r\n}\r\n\r\nexport function runTests(suites = getSuites()): void {\r\n    const runner = new TestRunner();\r\n    runner.run(suites);\r\n}\r\n","export class KT {\r\n    private name = 'KtCore';\r\n    private version = '1.0.0';\r\n\r\n    static salute() {\r\n        const obj = { name: 'KtCore', version: '1.0.0' };\r\n        alert(JSON.stringify(obj));\r\n        alert(`Hello from ${this.name} `);\r\n    }\r\n\r\n    static Module(name: string, module: any) {\r\n        if ((this as any)[name]) {\r\n            $.writeln(`Module ${name} already exists`);\r\n        }\r\n        (this as any)[name] = module;\r\n    }\r\n}\r\n","// src/tests/index.test.ts\r\nimport { describe, it, expect, runTests, getSuites } from '../index';\r\nimport { KT } from 'kt-core';\r\n\r\nKT.Module('Test', describe);\r\n\r\ndescribe('JS Matchers Suite', () => {\r\n    describe('Equality and Identity', () => {\r\n        // Happy Path: Identical values and deep equality\r\n        it('toBe passes with identical values', () => {\r\n            expect(true).toBe(true);\r\n            expect(1).toBe(1);\r\n            expect('test').toBe('test');\r\n        });\r\n\r\n        it('toEqual passes with deep object equality', () => {\r\n            expect({ a: 1, b: 'test' }).toEqual({ a: 1, b: 'test' });\r\n            expect([1, 2, 3]).toEqual([1, 2, 3]);\r\n        });\r\n\r\n        // Grey Path: Similar but not identical values\r\n        it('toBe fails with similar but non-identical values', () => {\r\n            expect(() => expect('1').toBe(1)).toThrow();\r\n            expect(() => expect({ a: 1 }).toBe({ a: 1 })).toThrow();\r\n        });\r\n\r\n        it('toEqual passes with nested objects', () => {\r\n            expect({ a: { b: 2 } }).toEqual({ a: { b: 2 } });\r\n        });\r\n\r\n        // Sad Path: Invalid or unexpected inputs\r\n        it('toBe handles null and undefined', () => {\r\n            expect(null).toBe(null);\r\n            expect(undefined).toBe(undefined);\r\n            expect(() => expect(null).toBe(undefined)).toThrow();\r\n        });\r\n\r\n        it('toEqual handles null and undefined', () => {\r\n            expect(null).toEqual(null);\r\n            expect(() => expect(null).toEqual(undefined)).toThrow();\r\n        });\r\n    });\r\n\r\n    describe('Existence and Type', () => {\r\n        // Happy Path: Correct type and existence\r\n        it('toBeDefined passes with defined values', () => {\r\n            expect('test').toBeDefined();\r\n            expect(0).toBeDefined();\r\n        });\r\n\r\n        it('toBeUndefined passes with undefined', () => {\r\n            let value;\r\n            expect(value).toBeUndefined();\r\n        });\r\n\r\n        it('toBeNull passes with null', () => {\r\n            expect(null).toBeNull();\r\n        });\r\n\r\n        it('toBeNumber passes with valid numbers', () => {\r\n            expect(42).toBeNumber();\r\n            expect(0).toBeNumber();\r\n            expect(-5.5).toBeNumber();\r\n        });\r\n\r\n        it('toBeNaN passes with NaN', () => {\r\n            expect(NaN).toBeNaN();\r\n        });\r\n\r\n        it('toBeString passes with strings', () => {\r\n            expect('hello').toBeString();\r\n            expect('').toBeString();\r\n        });\r\n\r\n        it('toBeBoolean passes with booleans', () => {\r\n            expect(true).toBeBoolean();\r\n            expect(false).toBeBoolean();\r\n        });\r\n\r\n        it('toBeFunction passes with functions', () => {\r\n            expect(function () {}).toBeFunction();\r\n            expect(() => {}).toBeFunction();\r\n        });\r\n\r\n        it('toBeArray passes with arrays', () => {\r\n            expect([]).toBeArray();\r\n            expect([1, 2, 3]).toBeArray();\r\n        });\r\n\r\n        // Grey Path: Edge cases or ambiguous inputs\r\n        it('toBeNumber fails with NaN', () => {\r\n            expect(() => expect(NaN).toBeNumber()).toThrow();\r\n        });\r\n\r\n        it('toBeNaN passes with invalid number parsing', () => {\r\n            expect(parseInt('invalid')).toBeNaN();\r\n        });\r\n\r\n        // Sad Path: Invalid types or unexpected inputs\r\n        it('toBeDefined fails with undefined', () => {\r\n            expect(() => expect(undefined).toBeDefined()).toThrow();\r\n        });\r\n\r\n        it('toBeNull fails with non-null', () => {\r\n            expect(() => expect(0).toBeNull()).toThrow();\r\n        });\r\n\r\n        it('toBeNumber fails with non-numbers', () => {\r\n            expect(() => expect('42').toBeNumber()).toThrow();\r\n            expect(() => expect(null).toBeNumber()).toThrow();\r\n        });\r\n\r\n        it('toBeString fails with non-strings', () => {\r\n            expect(() => expect(123).toBeString()).toThrow();\r\n        });\r\n    });\r\n\r\n    describe('Truthiness', () => {\r\n        // Happy Path: Clear truthy and falsy values\r\n        it('toBeTruthy passes with truthy values', () => {\r\n            expect(true).toBeTruthy();\r\n            expect(1).toBeTruthy();\r\n            expect('test').toBeTruthy();\r\n            expect({}).toBeTruthy();\r\n            expect([1]).toBeTruthy();\r\n        });\r\n\r\n        it('toBeFalsy passes with falsy values', () => {\r\n            expect(false).toBeFalsy();\r\n            expect(0).toBeFalsy();\r\n            expect('').toBeFalsy();\r\n            expect(null).toBeFalsy();\r\n            expect(undefined).toBeFalsy();\r\n        });\r\n\r\n        // Grey Path: Edge cases of truthiness\r\n        it('toBeTruthy passes with non-empty arrays', () => {\r\n            expect([0]).toBeTruthy(); // Array is truthy despite falsy content\r\n        });\r\n\r\n        // Sad Path: Unexpected or edge falsy/truthy cases\r\n        it('toBeTruthy fails with falsy values', () => {\r\n            expect(() => expect(0).toBeTruthy()).toThrow();\r\n        });\r\n\r\n        it('toBeFalsy fails with truthy values', () => {\r\n            expect(() => expect('non-empty').toBeFalsy()).toThrow();\r\n        });\r\n    });\r\n\r\n    describe('Size and Content', () => {\r\n        // Happy Path: Correct size and content\r\n        it('toBeEmpty passes with empty arrays and strings', () => {\r\n            expect([]).toBeEmpty();\r\n            expect('').toBeEmpty();\r\n        });\r\n\r\n        it('toHaveLength passes with matching lengths', () => {\r\n            expect([1, 2, 3]).toHaveLength(3);\r\n            expect('abc').toHaveLength(3);\r\n        });\r\n\r\n        it('toContain passes with substrings', () => {\r\n            expect('hello world').toContain('world');\r\n            expect('test').toContain('es');\r\n        });\r\n\r\n        it('toInclude passes with array elements', () => {\r\n            expect([1, 2, 3]).toInclude(2);\r\n            expect(['a', 'b']).toInclude('a');\r\n        });\r\n\r\n        // Grey Path: Edge cases of size/content\r\n        it('toBeEmpty passes with null and undefined', () => {\r\n            expect(null).toBeEmpty();\r\n            expect(undefined).toBeEmpty();\r\n        });\r\n\r\n        it('toHaveLength passes with zero length for null/undefined', () => {\r\n            expect(null).toHaveLength(0);\r\n            expect(undefined).toHaveLength(0);\r\n        });\r\n\r\n        it('toContain fails with partial matches', () => {\r\n            expect(() => expect('hello').toContain('world')).toThrow();\r\n        });\r\n\r\n        // Sad Path: Invalid or unexpected inputs\r\n        it('toBeEmpty fails with non-empty values', () => {\r\n            expect(() => expect([1]).toBeEmpty()).toThrow();\r\n            expect(() => expect('a').toBeEmpty()).toThrow();\r\n        });\r\n\r\n        it('toHaveLength fails with incorrect lengths', () => {\r\n            expect(() => expect('abc').toHaveLength(2)).toThrow();\r\n        });\r\n\r\n        it('toInclude fails with non-members', () => {\r\n            expect(() => expect([1, 2]).toInclude(3)).toThrow();\r\n        });\r\n    });\r\n\r\n    describe('Numeric Comparisons', () => {\r\n        // Happy Path: Correct comparisons\r\n        it('toBeGreaterThan passes with greater values', () => {\r\n            expect(5).toBeGreaterThan(3);\r\n            expect(0).toBeGreaterThan(-1);\r\n        });\r\n\r\n        it('toBeLessThan passes with lesser values', () => {\r\n            expect(3).toBeLessThan(5);\r\n            expect(-1).toBeLessThan(0);\r\n        });\r\n\r\n        it('toBeGreaterThanOrEqual passes with greater or equal values', () => {\r\n            expect(5).toBeGreaterThanOrEqual(3);\r\n            expect(5).toBeGreaterThanOrEqual(5);\r\n        });\r\n\r\n        it('toBeLessThanOrEqual passes with lesser or equal values', () => {\r\n            expect(3).toBeLessThanOrEqual(5);\r\n            expect(5).toBeLessThanOrEqual(5);\r\n        });\r\n\r\n        // Grey Path: Edge cases of equality\r\n        it('toBeGreaterThan fails with equal values', () => {\r\n            expect(() => expect(5).toBeGreaterThan(5)).toThrow();\r\n        });\r\n\r\n        it('toBeLessThan fails with equal values', () => {\r\n            expect(() => expect(5).toBeLessThan(5)).toThrow();\r\n        });\r\n\r\n        // Sad Path: Invalid numeric inputs\r\n        it('toBeGreaterThan fails with non-numbers', () => {\r\n            expect(() => expect('5').toBeGreaterThan(3)).toThrow();\r\n            expect(() => expect(null).toBeGreaterThan(0)).toThrow();\r\n        });\r\n\r\n        it('toBeLessThan handles NaN', () => {\r\n            expect(() => expect(NaN).toBeLessThan(5)).toThrow();\r\n        });\r\n    });\r\n\r\n    describe('Instance Checking', () => {\r\n        class TestClass {\r\n            constructor() {\r\n                let a = 1;\r\n            }\r\n        }\r\n\r\n        // Happy Path: Correct instance\r\n        it('toBeInstanceOf passes with correct instance', () => {\r\n            var instance = new TestClass();\r\n            expect(instance).toBeInstanceOf(TestClass);\r\n        });\r\n\r\n        // Grey Path: Subclass or similar type\r\n        it('toBeInstanceOf fails with subclass', () => {\r\n            class SubClass extends TestClass {}\r\n            var instance = new SubClass();\r\n            expect(instance).toBeInstanceOf(TestClass); // Should pass in JS, but testing specificity\r\n        });\r\n\r\n        // Sad Path: Wrong type or null\r\n        it('toBeInstanceOf fails with wrong type', () => {\r\n            expect(() => expect({}).toBeInstanceOf(TestClass)).toThrow();\r\n            expect(() => expect(null).toBeInstanceOf(TestClass)).toThrow();\r\n        });\r\n\r\n        //Works with Adobe built-in classes\r\n        it('toBeInstanceOf passes with built-in classes', () => {\r\n            const comp = app.project.items.addComp(\r\n                'Test',\r\n                1920,\r\n                1080,\r\n                1,\r\n                10,\r\n                30\r\n            );\r\n            expect(comp).toBeInstanceOf(CompItem);\r\n            comp.remove();\r\n        });\r\n    });\r\n});\r\n\r\nrunTests(getSuites());\r\n"],"names":["_proto","expectInstance","toThrow","isFunction","threw","toBe","toEqual","toBeDefined","toBeUndefined","toBeNull","toBeTruthy","toBeFalsy","toBeArray","isArray","toBeEmpty","isString","toHaveLength","toBeNumber","isNumber","toBeNaN","toBeString","toBeBoolean","isBoolean","toBeFunction","toBeGreaterThan","isGreater","toBeLessThan","isLess","toBeGreaterThanOrEqual","isGreaterOrEqual","toBeLessThanOrEqual","isLessOrEqual","toContain","contains","toInclude","includes","toBeInstanceOf","isInstance","toBeActiveComp","toHaveDuration","toBeComp","currentSuite","description","tests","suites","fn","name","_defineProperty","$","_iterator2","_iterator","runner","KT","version","alert","describe","expect","a","b","runTests"],"mappings":"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"}